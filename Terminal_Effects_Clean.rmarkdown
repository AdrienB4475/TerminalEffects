---
title: "Studying Terminal Effects in Northern Elephant Seals"
output-file: index
format:
  html:
    echo: false
    fig-width: 7
    fig-height: 5
    code-fold: true
    code-tools: true
    warning: false
    toc: true
editor: visual
editor_options: 
  chunk_output_type: console
---




# Downloading the Data and Libraries




```{r}
#| label: setup

#Libraries: 
library (tidyverse)
library (dplyr)
library (ggplot2)
library (lme4)
library (brms)
library (ggeffects)
library (tidybayes)
library (rstan)
library(loo)


#Initial Data Pull
sealdat <- read_csv(here::here("data/Adrien Data Pull 2024_12_06.csv"), show_col_types = FALSE)

maturity <- 6
prime_max <- 14
```




# Modified Datasets




```{r}
#BIOSEAL (creates terminal status and calculates age)
bioseal <- sealdat %>% filter(observed == 1, tagsex == "F") %>%
  group_by(animalID) %>%
  mutate(age = year - yearborn, 
         max_age = max(age), 
         bio_age = max_age - age, 
         terminal = ifelse(bio_age == 0, 1, 0),
         firstobsbreed = as.Date(firstobsbreed, format = "%Y-%m-%d"), 
         lastobsbreed = as.Date(lastobsbreed, format = "%Y-%m-%d"), 
         lactation_duration = as.numeric(difftime(lastobsbreed, firstobsbreed, units = "days"))) %>%
  filter(age > 2, 
         year > 1987)

#Full Resight database 
resight <- read_csv(here::here("data/raw/fullresights.csv")) %>%
  filter(obssex == "F" & timeofyear == "Breeding") %>%
  rename(year = calyear) %>%
  group_by(animalID) %>%
  mutate(
    age = year - yearborn,
    max_age = max(age, na.rm = TRUE),
    bio_age = max_age - age,
    terminal = ifelse(bio_age == 0, 1, 0)
  ) %>%
  filter(age > 2,
         year > 1987) %>%
  ungroup()

#PUP SURVIVAL
pup_surv_dat <- read_csv(here::here("data/raw/128L pull 2023_12_05.csv"),
                         show_col_types = FALSE) %>% 
  mutate(observed = if_else(observed == "B", "Breeder", "Non-breeder"), 
         observed_int = if_else(observed == "Breeder", 1, 0), 
         pup_survived = pupseeneveragain > 0) %>% 
  filter(age > 3, 
         year > 1987) %>% 
  group_by(animalID) %>% 
  mutate(firstrepro = ifelse(max(year) < 2020 && any(observed_int == 1),
                             min(age[observed_int == 1]),
                             NA),
         lastrepro = ifelse(max(year) < 2020 && any(observed_int == 1),
                            max(age[observed_int == 1]),
                            NA),
         lastobs = ifelse(max(year) < 2020, max(age), NA),
         max_age = max(age, na.rm = TRUE),
         bio_age = max_age - age,
         terminal = ifelse(bio_age == 0, 1, 0),
         ageclass = ifelse(age <= maturity, "pre-prime", "experienced"),
         age10 = (age - maturity) / 10, 
         year_fct = factor(season),
         pup_surv_int = as.integer(pup_survived),
         ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
         age_prime = (age - maturity) * (age >= maturity),
         age_post_prime = (age - prime_max) * (age >= prime_max),
         ) %>% 
  ungroup()
```




# Adult Female Population Figure




```{r}
#Create terminal to be a factor here 
pop_breed <- bioseal %>%
  group_by(age, terminal) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal")))

#Figure with age distribution with terminal as a factor to create a stacked barplot
pop_fig <- ggplot(pop_breed, aes(x = factor(age), y = n, fill = terminal_fct)) +
  geom_col() +
  labs(
    x = "Age",
    y = "Number of Individuals",
    fill = "Terminal Status",
    title = "# of Adult Females by Terminal Status"
  ) +
  #Insert Cute theme!
  theme_minimal(base_size = 15) +
  theme(
    panel.grid.major = element_line(color = "pink", linewidth = 0.3),  
    panel.grid.minor = element_blank(),  
    axis.title.x = element_text(color = "#8E44AD", size = 14, face = "bold"),  
    axis.title.y = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.text.x = element_text(color = "#7F8C8D", size = 12),  
    axis.text.y = element_text(color = "#7F8C8D", size = 12),
    plot.title = element_text(hjust = 0.5, size = 18, face = "italic", color = "purple"),  
    legend.title = element_text(size = 12, face = "bold", color = "purple"),
    legend.text = element_text(size = 12, color = "purple")
  ) +
  scale_fill_manual(values = c("Nonterminal" = "#6DD5B3", "Terminal" = "#D5A6F6"))

print(pop_fig)
```




# Lactation Duration Model and Figures

1.) Modify the data set to only contain females so when "obssex" = "F" during the breeding season so when timeofyear = breeding

2.) Then contain only adult females observed with a pup

3.) Then calculation lactation duration using earliest date when "withpup" = 1 and then latest date when "withpup" = 1




```{r}

#Calculating lactation duration 
lact_info <- resight %>%
  filter(withpup == 1) %>%
  group_by(animalID, season, age, max_age, bio_age, terminal) %>%
  summarise(
    lact_start = min(date, na.rm = TRUE),
    lact_end = max(date, na.rm = TRUE), 
    lact_dur = as.numeric(lact_end - lact_start),
    .groups = "drop"
  ) %>%
  filter(lact_dur > 0)

lact_dat2 <- lact_info %>% 
  dplyr::select(animalID, bio_age, lact_dur, season, terminal, age) %>% 
  mutate( 
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max), 
    season_fct = factor(season))

lact_dat2 <- lact_dat2 %>% 
  distinct(animalID, season, .keep_all = TRUE)

lact_count <- lact_dat2 %>%
  group_by(age, age_prime, age_post_prime, ageclass3, terminal) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))) %>%
  complete(age, age_prime, age_post_prime, ageclass3, terminal_fct, fill = list(n = 0))

lact_top    <- 1.5   # Terminal (regular font) 
lact_bot <- 0.1   # Nonterminal (italic font)
```




## Lactation Duration Model with Bayesian Stats




```{r}

#Then set a prior for everything starting with Intercept 
lact_prior <- c(
  prior(normal(22, 3), class = "Intercept"),
  prior(normal(0, 5), class = "b", coef = "age"),
  prior(normal(0, 5), class = "b", coef = "age_post_prime"),
  prior(normal(0, 5), class = "b", coef = "age_prime"),
  prior(normal(0, 5), class = "b", coef = "terminal:ageclass3postMprime"),
  prior(normal(0, 5), class = "b", coef = "terminal:ageclass3preMprime"),
  prior(normal(0, 5), class = "b", coef = "terminal:ageclass3prime"),
  prior(student_t(3,0, 5), class = "sd", group = "animalID"),
  prior(student_t(3,0, 5), class = "sd", group = "season_fct")
)


#Brm model for lac dur
lac_brm <- brm(
  lact_dur ~ age + age_prime + age_post_prime + terminal:ageclass3 + (1 | animalID) + (1 | season_fct),
  data   = lact_dat2,
  prior = lact_prior,
  family = negbinomial(),
  iter    = 4000, 
  chains  = 4,  
  backend = "rstan"   
)

summary(lac_brm)
pp_check(lac_brm)

# # Prediction grid
lac_grid2 <- tidyr::expand_grid(
  age = 3:22,
  terminal = 0:1
) %>%
  mutate(
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max),
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    terminal_fct = factor(terminal, labels = c("Nonterminal","Terminal"))
  )
 
# Population-level predictions (exclude random effects), with 95% CrI
pred_df <- fitted(
  lac_brm,
  newdata    = lac_grid2,
  re_formula = NA,
  summary    = TRUE,
  probs      = c(0.025, 0.975)
) %>% as_tibble()

lac_pred_pop2 <- bind_cols(lac_grid2, pred_df) %>%
  rename(
    predicted = Estimate,
    lwr       = Q2.5,
    upr       = Q97.5
  )

# Raw-data summaries 
lact_summ2 <- lact_dat2 %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal","Terminal"))) %>%
  group_by(age, terminal_fct, ageclass3) %>%
  summarize(
    mean_lact = mean(lact_dur),
    se_lact   = sd(lact_dur) / sqrt(n()),
    .groups   = "drop"
  ) %>%
  mutate(age = age + 0.15 * ifelse(terminal_fct == "Terminal", 1, -1))

#Lactation Duration Plot
ggplot(lac_pred_pop2, aes(x = age, y = predicted)) +
  geom_ribbon(
    aes(ymin = lwr, ymax = upr,
        fill = ageclass3,
        group = interaction(ageclass3, terminal_fct)),
    alpha = 0.20, show.legend = TRUE
  ) +
  geom_line(
    aes(linetype = terminal_fct, color = ageclass3,
        group = interaction(ageclass3, terminal_fct)),
    linewidth = 1.2
  ) +
  geom_pointrange(
    data = lact_summ2,
    aes(
      y = mean_lact,
      ymin = mean_lact - 1.96 * se_lact,
      ymax = mean_lact + 1.96 * se_lact,
      color = ageclass3,
      linetype = terminal_fct
    ),
    show.legend = FALSE
  ) +
  geom_vline(xintercept = maturity + 0.5, linetype = "dashed", color = "#9B59B6") +
  geom_vline(xintercept = prime_max + 0.5, linetype = "dashed", color = "#9B59B6") +

  #Add Counts to Plot
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(12, 18, 12, 12)) +
  geom_text(
    data = lact_count %>% filter(terminal_fct == "Terminal", n > 0),
    aes(x = age, y = Inf, label = n,
        group = interaction(ageclass3, terminal_fct)),
    vjust = 1.8, size = 3.2, color = "black", fontface = "plain",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = lact_count %>% filter(terminal_fct == "Nonterminal", n > 0),
    aes(x = age, y = Inf, label = n,
        group = interaction(ageclass3, terminal_fct)),
    vjust = 3.5, size = 3.2, color = "black", fontface = "italic",
    inherit.aes = FALSE
  ) +

  # Insert My Personal Theme!
  theme_minimal() +
  theme(
    panel.background  = element_rect(fill = "#F9F9F9", color = NA),
    panel.border      = element_rect(color = "black", fill = NA, linewidth = 0.8),  # solid box
    axis.line         = element_line(color = "black", linewidth = 0.6),             # solid axes
    axis.ticks        = element_line(color = "black"),
    axis.title.x      = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.title.y      = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.text.x       = element_text(color = "#7F8C8D", size = 12),
    axis.text.y       = element_text(color = "#7F8C8D", size = 12),
    plot.title        = element_text(hjust = 0.5, size = 18, face = "italic",
                                     color = "#8E44AD"),
    legend.title      = element_text(size = 13, face = "bold"),
    legend.text       = element_text(size = 11)
  ) +
  labs(
    title = "Effect of Age on Lactation Duration",
    x = "Mother's Age (Years)",
    y = "Lactation Duration (days)",
    color = "Age Class",
    fill  = "Age Class",
    linetype = "Terminal Status"
  ) +
  scale_linetype_manual(values = c("Nonterminal" = "solid", "Terminal" = "dotdash")) +
   scale_color_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2")) +
  scale_fill_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2"))


```




## Lactation Duration Results Summary

Rhat =1.0; models convergence is accurate, intervals accurate

Seasonal differences (sd = 0.11) matter more than individual differences (sd = .02)

Age does not directly correlate to trend (Est = .02)

Terminal experienced mothers negative and credibly below 0 (Est -0.06)

About a 6% shorter lactation duration for terminal experienced mothers compared to non-terminal experienced mothers

Terminal status in inexperienced mothers (Est -0.02) does not have strong correlation

Takeaway: Overall, terminal status only effected experienced mothers, all other effects are uncertain.

# Wean Weight Model




```{r}

# #Data Prep
wt_dat <- bioseal %>%
  dplyr::select(animalID, bio_age, lactation_duration, year, pupsex, Wt, age) %>%
  filter(!is.na(Wt), !is.na(age)) %>%
  mutate(
    terminal   = as.integer(ifelse(bio_age == 0, 1, 0)),
    terminal_fct = factor(terminal, levels = c(0,1),
                          labels = c("Nonterminal", "Terminal")),
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max),
    year_fct       = factor(year),
    animalID   = factor(animalID)
  )

#Plotting counts: 
wt_count <- wt_dat %>%
  group_by(age, age_prime, age_post_prime, ageclass3, terminal) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))) %>%
  complete(age, age_prime, age_post_prime, ageclass3, terminal_fct, fill = list(n = 0))

wt_top    <- 1.5   # Terminal (regular font) 
wt_bot <- 0.1   # Nonterminal (italic font) 

#Setting Priors with Gausian family 
priors_wt <- c(
  prior(normal(100, 10), class = "Intercept"),
  prior(normal(0,4), class = "b"),
  prior(student_t(3, 0, 20), class = "sd", group = "animalID"),
  prior(student_t(3, 0, 20), class = "sd", group = "year_fct"),
  prior(student_t(3, 0, 20), class = "sigma")
)


# Bayesian Model
wt_brm <- brm(
  Wt ~ age + age_prime + age_post_prime +
    terminal:ageclass3 + 
    (1 | year_fct) + (1 | animalID),
  data   = wt_dat,
  family = gaussian(),
  prior = priors_wt, 
  iter    = 4000, 
  chains  = 4,  
  backend = "rstan"
)

summary(wt_brm)
pp_check(wt_brm)

# Pred Grid
wt_grid <- tidyr::expand_grid(
  age = 3:22,
  terminal = 0:1
) %>%
  mutate(
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max),
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    terminal_fct = factor(terminal, levels = c(0,1),
                          labels = c("Nonterminal","Terminal"))
  )

wt_pred <- fitted(
  wt_brm,
  newdata    = wt_grid,
  re_formula = NA,
  summary    = TRUE,
  probs      = c(0.025, 0.975)
) %>% as_tibble()

wt_pred_pop <- bind_cols(wt_grid, wt_pred) %>%
  rename(predicted = Estimate, lwr = Q2.5, upr = Q97.5) %>%
  arrange(age)

#Data Summary
wt_summ <- wt_dat %>%
  group_by(age, terminal_fct, ageclass3) %>%
  summarize(
    mean_wt = mean(Wt, na.rm = TRUE),
    se_wt   = sd(Wt,   na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  mutate(age = age + 0.15 * ifelse(terminal_fct == "Terminal", 1, -1))

#Wean Weight Plot
ggplot(wt_pred_pop, aes(x = age, y = predicted)) +
  geom_ribbon(
    aes(ymin = lwr, ymax = upr, fill = ageclass3,
        group = interaction(ageclass3, terminal_fct)),
    alpha = 0.20
  ) +
  geom_line(
    aes(linetype = terminal_fct, color = ageclass3,
        group = interaction(ageclass3, terminal_fct)),
    linewidth = 1.2
  ) +
  geom_pointrange(
    data = wt_summ,
    aes(y = mean_wt,
        ymin = mean_wt - 1.96 * se_wt,
        ymax = mean_wt + 1.96 * se_wt,
        color = ageclass3,
        linetype = terminal_fct),
    show.legend = FALSE
  ) +
  geom_vline(xintercept = maturity + 0.5, linetype = "dashed", color = "#9B59B6") +
  geom_vline(xintercept = prime_max + 0.5, linetype = "dashed", color = "#9B59B6") +
  
#Plot Counts 
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(12, 18, 12, 12)) +
  geom_text(
    data = wt_count %>% filter(terminal_fct == "Terminal", n > 0),
    aes(x = age, y = Inf, label = n, group = interaction(ageclass3, terminal_fct)),
    vjust = wt_top, size = 3.2, color = "black", fontface = "plain",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = wt_count %>% filter(terminal_fct == "Nonterminal", n> 0),
    aes(x = age, y = Inf, label = n, group = interaction(ageclass3, terminal_fct)),
    vjust = wt_bot + 4, size = 3.2, color = "black", fontface = "italic",
    inherit.aes = FALSE
  ) +
  
#Insert Personal theme!
  theme(
    panel.background = element_rect(fill = "#F9F9F9"),
    panel.border      = element_rect(color = "black", fill = NA, linewidth = 0.5),
    axis.line         = element_line(color = "black", linewidth = 0.6),
    axis.ticks        = element_line(color = "black"),
    axis.title.x = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.title.y = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.text.x = element_text(color = "#7F8C8D", size = 12),
    axis.text.y = element_text(color = "#7F8C8D", size = 12),
    plot.subtitle = element_text(hjust = 0.5, size = 12, color = "purple"),
    plot.title = element_text(hjust = 0.5, size = 18, face = "italic", color = "#8E44AD"),
    legend.title = element_text(size = 13, face = "bold"),
    legend.text = element_text(size = 11)
  ) +
  labs(
    title = "Impact of Age on Wean Weight",
    x = "Mother's Age (Years)",
    y = "Wean Weight (kg)",
    color = "Age Class",
    linetype = "Terminal Status"
  ) +
  scale_linetype_manual(values = c("Nonterminal" = "solid", "Terminal" = "dotdash")) +
  scale_color_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2")) +
  scale_fill_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2"))

```




## Wean Weight Summary Results

Rhat = 1 which means the model converged nicely meaning all estimates should be reliable.

From this, we see that age has a positive outcome on the effect (Est: + 10.37)

Prime (Est -8.88) and Post-prime (Est -6.03) age classes are credibly lower

Estimates don't support that terminal status interacting with age class changes chance of wean weight outcome.

Variation for individual(Est: 9.86) and year (Est: 7.74) are substantial

# Sex Ratios Model and Figure

We hypothesize that young terminal moms will have a higher chance of giving birth to a male offspring sex ratio than non terminal moms. Whereas old terminal moms will produce less males compared to non terminal moms




```{r}
# Offspring sex ratio dataset 
sex_dat <- bioseal %>%
  dplyr::select(animalID, bio_age, pupsex, age, year) %>% 
  filter(!is.na(pupsex)) %>%
  mutate(
    is_male = ifelse(pupsex == "M", 1, 0),  # 1 = male, 0 = female
    terminal = ifelse(bio_age == 0, 1, 0), 
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max),
    year_fct = factor(year)
  )

#Count for all ageclass, age, and terminal status individuals to plot onto graph:
sex_count <- sex_dat %>%
  group_by(age, age_prime, age_post_prime, ageclass3, terminal) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))) %>%
  complete(age, age_prime, age_post_prime, ageclass3, terminal_fct, fill = list(n = 0))

sex_top    <- 1.5   # Terminal (regular font) 
sex_bot <- 0.1   # Nonterminal (italic font) 

#Setting priors 
priors_sex <- c(
  prior(normal(0, 2), class = "Intercept"),
  prior(normal(0, 2), class = "b", coef = "age"),
  prior(normal(0, 2), class = "b", coef = "age_post_prime"),
  prior(normal(0, 2), class = "b", coef = "age_prime"),
  prior(normal(0, 2), class = "b", coef = "terminal:ageclass3postMprime"),
  prior(normal(0, 2), class = "b", coef = "terminal:ageclass3preMprime"),
  prior(normal(0, 2), class = "b", coef = "terminal:ageclass3prime"),
  prior(student_t(3, 0, 2), class = "sd", group = "animalID"),
  prior(student_t(3, 0, 2), class = "sd", group = "year_fct")
)

# Brms Model 

sex_mod <- brm(
  is_male ~ age + age_prime + age_post_prime + terminal:ageclass3 + (1 | animalID) + (1 | year_fct),
  data    = sex_dat,
  family  = bernoulli(link = "logit"),
  prior = priors_sex, 
  iter    = 4000, 
  chains  = 4,  
  backend = "rstan"  
)

summary(sex_mod)
pp_check(sex_mod)

#  Prediction grid 
sex_grid <- tidyr::expand_grid(
  age = 3:22, 
  terminal = 0:1
) %>% 
  mutate(
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max),
  )

# fitted() collects the predicted values from brms() and we will store in pred_mat and then put back into grid 
pred_mat <- fitted(
  sex_mod,
  newdata     = sex_grid,
  re_formula  = NA,
  summary     = TRUE
)
# Add to grid
sex_pred_pop <- sex_grid %>%
  mutate(
    predicted_prob_male = pred_mat[, "Estimate"],
    ci_low = pred_mat[, "Q2.5"],
    ci_high = pred_mat[, "Q97.5"],
    terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))
  )

#Summary 
sex_summ <- sex_dat %>%
  ungroup() %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))) %>%
  group_by(age, terminal_fct, ageclass3) %>%
  summarize(
    prop_male = mean(is_male, na.rm = TRUE),
    se_prop = sqrt((prop_male * (1 - prop_male)) / n()), 
    .groups = "drop"
  ) %>%
  mutate(age = age + 0.15 * ifelse(terminal_fct == "Terminal", 1, -1))

# Sex Pred Fig
ggplot(sex_pred_pop, aes(x = age, y = predicted_prob_male)) +
 geom_ribbon(
   aes(ymin = ci_low, ymax = ci_high, fill = ageclass3, 
             group = interaction(ageclass3, terminal_fct)),
             alpha = 0.15, show.legend = FALSE) +
  geom_pointrange(
    data = sex_summ,
    aes(
      y = prop_male, 
      ymin = prop_male - 1.96 * se_prop, 
      ymax = prop_male + 1.96 * se_prop, 
      linetype = terminal_fct,
      color = ageclass3
    ),
    show.legend = FALSE
  ) +
  geom_line(aes(
    linetype = terminal_fct,
    color = ageclass3
  ), linewidth = 1.2) +
  geom_vline(xintercept = maturity + 0.5, linetype = "dashed", color = "#9B59B6") +
  geom_vline(xintercept = prime_max + 0.5, linetype = "dashed", color = "#9B59B6") +
  geom_hline(yintercept = 0.5, linetype = "dashed", color = "black") +
  
#Add Counts
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(12, 18, 12, 12)) +
  geom_text(
    data = sex_count %>% filter(terminal_fct == "Terminal", n > 0),
    aes(x = age, y = Inf, label = n, group = interaction(ageclass3, terminal_fct)),
    vjust = sex_top, size = 3.2, color = "black", fontface = "plain",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = sex_count %>% filter(terminal_fct == "Nonterminal", n> 0),
    aes(x = age, y = Inf, label = n, group = interaction(ageclass3, terminal_fct)),
    vjust = sex_bot + 4, size = 3.2, color = "black", fontface = "italic",
    inherit.aes = FALSE
  ) +
  
#Insert Cute theme!
  theme_minimal() +
  theme(
    panel.background = element_rect(fill = "#F9F9F9"),
    axis.title.x = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.title.y = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.text.x = element_text(color = "#7F8C8D", size = 12),
    axis.text.y = element_text(color = "#7F8C8D", size = 12),
    plot.subtitle = element_text(hjust = 0.5, size = 12, color = "purple"),
    plot.title = element_text(hjust = 0.5, size = 18, face = "italic", color = "#8E44AD"),
    legend.title = element_text(size = 13, face = "bold"),
    legend.text = element_text(size = 11)
  ) +
  labs(
    title = "Offspring Sex Ratio by Maternal Age", 
    subtitle = "Terminal vs Non-Terminal Mothers",
    x = "Mother's Age (Years)", 
    y = "Probability Offspring is Male",
    color = "Age Class",
    linetype = "Terminal Status"
  ) +
  scale_linetype_manual(values = c("Nonterminal" = "solid", "Terminal" = "dotdash")) +
  scale_color_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2")) +
  scale_fill_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2"))
```




## Offspring Sex Ratio Summary Results:

Rhat = 1 which means the model converged nicely meaning all estimates should be reliable.

Slight variation for individual and year (Est: 0.17 for both)

Only terminal status is positively associate with the outcome in experienced mothers (Est: 0.39)

Effects of age are uncertain, intercept near 0 and not credibly different than 0

# Pup Survival Figure




```{r}
# Isolate pup survival/recruitment 
surv_recr_data <- pup_surv_dat %>% 
  drop_na(pupID) %>% 
  # Only pups born 2016 or earlier (otherwise survival biased)
  filter(pupyearborn <= 2016) %>% 
  filter(age < 20) %>% 
  mutate(pup_surv_int = as.integer(pup_survived))

#Count Data
pup_count <- pup_surv_dat %>%
  group_by(age, age_prime, age_post_prime, ageclass3, terminal) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))) %>%
  complete(age, age_prime, age_post_prime, ageclass3, terminal_fct, fill = list(n = 0))

pup_top    <- 1.5   # Terminal (regular font) 
pup_bot <- 0.1   # Nonterminal (italic font) 

#Specify Priors here:
pup_surv_prior <- c(
  prior(normal(0, 5), class = Intercept),
  prior(normal(0, 2), class = b, coef = "age"),
  prior(normal(0, 2), class = b, coef = "age_post_prime"),
  prior(normal(0, 2), class = b, coef = "age_prime"),
  prior(normal(0, 2), class = b, coef = "terminal:ageclass3preMprime"),
  prior(normal(0, 2), class = b, coef = "terminal:ageclass3postMprime"),
  prior(normal(0, 2), class = b, coef = "terminal:ageclass3prime")
 )

#Pup Surv Model
pup_surv_mod <- brm(
  pup_surv_int ~ age + age_prime + age_post_prime + terminal:ageclass3 + 
   (1 | animalID) + (1 | year_fct),
  prior = pup_surv_prior,
  data    = surv_recr_data,
  family  = bernoulli(link = "logit"),
  iter    = 4000, 
  chains  = 4, 
  backend = "rstan"  
)

summary(pup_surv_mod)
pp_check(pup_surv_mod)

#  Prediction grid 
pup_grid <- tidyr::expand_grid(
  age = 3:22, 
  terminal = 0:1
) %>% 
  mutate(
    age_prime = (age - maturity) * (age >= maturity),
    age_post_prime = (age - prime_max) * (age >= prime_max),
    ageclass3  = cut(age, 
                     breaks = c(0, maturity, prime_max, Inf),
                     labels = c("pre-prime", "prime", "post-prime")),
    terminal_fct = factor(terminal, levels = c(0,1),
                          labels = c("Nonterminal","Terminal"))
  )

# fitted() collects the predicted values from brms() and we will store in pred_mat and then put back into grid 
pup_mat <- fitted(
  pup_surv_mod,
  newdata     = pup_grid,
  re_formula  = NA,
  summary     = TRUE
)


# Add to grid
pup_surv_pop <- pup_grid %>%
  mutate(
    predicted_pup_surv = pup_mat[, "Estimate"],
    ci_low = pup_mat[, "Q2.5"],
    ci_high = pup_mat[, "Q97.5"],
    terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))
  )

#Summary 
pup_summ <- pup_surv_dat %>%
  ungroup() %>%
  mutate(terminal_fct = factor(terminal, labels = c("Nonterminal", "Terminal"))) %>%
  group_by(age, terminal_fct, ageclass3) %>%
  summarize(
    prop_surv = mean(pup_surv_int, na.rm = TRUE),
    se_prop = sqrt((prop_surv * (1 - prop_surv)) / n()), 
    .groups = "drop"
  ) %>%
  mutate(age = age + 0.15 * ifelse(terminal_fct == "Terminal", 1, -1))

# Pup Survival Fig
ggplot(pup_surv_pop, aes(x = age, y = predicted_pup_surv)) +
 geom_ribbon(
   aes(ymin = ci_low, ymax = ci_high, fill = ageclass3, 
             group = interaction(ageclass3, terminal_fct)),
             alpha = 0.15, show.legend = FALSE) +
  geom_pointrange(
    data = pup_summ,
    aes(
      y = prop_surv, 
      ymin = prop_surv - 1.96 * se_prop, 
      ymax = prop_surv + 1.96 * se_prop, 
      linetype = terminal_fct,
      color = ageclass3
    ),
    show.legend = FALSE
  ) +
  geom_line(aes(
    linetype = terminal_fct,
    color = ageclass3
  ), linewidth = 1.2) +
  geom_vline(xintercept = maturity + 0.5, linetype = "dashed", color = "#9B59B6") +
  geom_vline(xintercept = prime_max + 0.5, linetype = "dashed", color = "#9B59B6") +
 
 #Plot Counts 
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(12, 18, 12, 12)) +
  geom_text(
    data = pup_count %>% filter(terminal_fct == "Terminal", n > 0),
    aes(x = age, y = Inf, label = n, group = interaction(ageclass3, terminal)),
    vjust = pup_top, size = 3.2, color = "black", fontface = "plain",
    inherit.aes = FALSE
  ) +
  geom_text(
    data = pup_count %>% filter(terminal_fct == "Nonterminal", n> 0),
    aes(x = age, y = Inf, label = n, group = interaction(ageclass3, terminal_fct)),
    vjust = pup_bot + 4, size = 3.2, color = "black", fontface = "italic",
    inherit.aes = FALSE
  ) +
  
#Insert Cute theme!
  theme(
    panel.background = element_rect(fill = "#F9F9F9"),
    panel.border      = element_rect(color = "black", fill = NA, linewidth = 0.5),
    axis.line         = element_line(color = "black", linewidth = 0.6),
    axis.ticks        = element_line(color = "black"),
    axis.title.x = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.title.y = element_text(color = "#8E44AD", size = 14, face = "bold"),
    axis.text.x = element_text(color = "#7F8C8D", size = 12),
    axis.text.y = element_text(color = "#7F8C8D", size = 12),
    plot.subtitle = element_text(hjust = 0.5, size = 12, color = "purple"),
    plot.title = element_text(hjust = 0.5, size = 18, face = "italic", color = "#8E44AD"),
    legend.title = element_text(size = 13, face = "bold"),
    legend.text = element_text(size = 11)
  ) +

  # Axis labels and legends
  labs(
    title = "Pup Survival Probability",
    x = "Mother's Age (Years)",
    y = "Pup Survival Probability",
    color = "Age Class",
    linetype = "Terminal Status"
  ) +

  # My custom palette styling for lines and fill
  scale_linetype_manual(values = c("Nonterminal" = "solid", "Terminal" = "dotdash")) +
  scale_color_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2")) +
  scale_fill_manual(values = c("#D5A6F6", "#6DD5B3", "#9B59B6", "#66B2B2"))
```




## Pup Survival Results Summary

Rhat **= 1** for all parameters, indicating good convergence and reliable estimates.

Moderate variation among individuals (SD = 0.44) and years (SD = 0.56), showing some random effect influence.

The effects of age and age class are uncertai**n**, as their estimates overlap zero and are not credibly different from 0.

The interaction between terminal status and age class is weak overall, for some reason, there is a very large negative and highly uncertain estimate for the post-prime moms (Est: –420 ± 551), which suggests an the effect can be unstable or just highly uncertain

Overall, the model shows no strong evidence for consistent effects of age, age class, or terminal status on the outcome, with wide uncertainty across parameters. no credibility according to the bayesian stats summary

# WAIC Comparisons

## Lactation Duration 




```{r}
waic(lac_brm)

#Setting up our competing models

#lac_brm will serve as our breakpoint model

#Linear model: 
lac_lin <- brm(
  lact_dur ~ age +
    terminal:ageclass3 +
    (1 | animalID) + (1 | season_fct),
  data   = lact_dat2,
  family = negbinomial(),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Quadratic model:
#Create a centered age and squared age 
lact_dat2 <- lact_dat2 %>% 
  mutate(
    age_c  = age - mean(age, na.rm = TRUE),
    age_c2 = age_c^2
  )

lac_quad <- brm(
  lact_dur ~ age_c + age_c2 +
    terminal:ageclass3 +
    (1 | animalID) + (1 | season_fct),
  data   = lact_dat2,
  family = negbinomial(),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Now add WAIC comparisons to each of these 
# add WAIC to each fitted model
lac_brm <- add_criterion(lac_brm, "waic")
lac_quad  <- add_criterion(lac_quad,  "waic")
lac_lin   <- add_criterion(lac_lin,   "waic")

#Quick Comparison
loo_compare(lac_brm, lac_quad, lac_lin, criterion = "waic")

#Then list out/ summary
lac_mods <- list(
  Breakpoint = lac_brm,
  Quadratic  = lac_quad,
  Linear     = lac_lin
)

#Now we prepare it to be in a table with weights for docs!
# extract WAIC estimates
waic_lac <- c(
  Breakpoint = lac_brm$criteria$waic$estimates["waic", "Estimate"],
  Quadratic  = lac_quad$criteria$waic$estimates["waic", "Estimate"],
  Linear     = lac_lin$criteria$waic$estimates["waic", "Estimate"]
)

# ΔWAIC relative to best model
min_waic   <- min(waic_lac)
delta_waic <- waic_lac - min_waic

# model weights based on WAIC
lac_weights <- exp(-0.5 * delta_waic)
lac_weights <- lac_weights / sum(lac_weights)

# Build comparison table
lac_waic_tab <- tibble::tibble(
  Model      = names(waic_lac),
  WAIC       = round(waic_lac, 2),
  `Δ WAIC`   = round(delta_waic, 2),
  Weight     = round(lac_weights, 3)
)

view(lac_waic_tab)
```




## Wean Weight 




```{r}
#Set up competing models
#wt_brm will serve as breakpoint model

wt_lin <- brm(
  Wt ~ age +
    terminal:ageclass3 +
    (1 | animalID) + (1 | year_fct),
  data   = wt_dat,
  family = gaussian(),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Quadratic Model: 
#Create a centered age and squared age 
wt_dat <- wt_dat %>% 
  mutate(
    age_c  = age - mean(age, na.rm = TRUE),
    age_c2 = age_c^2
  )

wt_quad <- brm(
  Wt ~ age_c + age_c2 +
    terminal:ageclass3 +
    (1 | animalID) + (1 | year_fct),
  data   = wt_dat,
  family = gaussian(),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Now add WAIC comparisons to each of these 
# add WAIC to each fitted model
wt_brm <- add_criterion(wt_brm, "waic")
wt_quad  <- add_criterion(wt_quad,  "waic")
wt_lin   <- add_criterion(wt_lin,   "waic")

#Quick Comparison
loo_compare(wt_brm, wt_quad, wt_lin, criterion = "waic")

#Then list out/ summary
wt_mods <- list(
  Breakpoint = wt_brm,
  Quadratic  = wt_quad,
  Linear     = wt_lin
)

#Now we prepare it to be in a table with weights for docs!
# extract WAIC estimates
waic_wt <- c(
  Breakpoint = wt_brm$criteria$waic$estimates["waic", "Estimate"],
  Quadratic  = wt_quad$criteria$waic$estimates["waic", "Estimate"],
  Linear     = wt_lin$criteria$waic$estimates["waic", "Estimate"]
)

# ΔWAIC relative to best model
wt_min_waic   <- min(waic_wt)
wt_delta_waic <- waic_wt - wt_min_waic

# model weights based on WAIC
wt_weights <- exp(-0.5 * wt_delta_waic)
wt_weights <- wt_weights / sum(wt_weights)

# Build comparison table
wt_waic_tab <- tibble::tibble(
  Model      = names(waic_wt),
  WAIC       = round(waic_wt, 2),
  `Δ WAIC`   = round(wt_delta_waic, 2),
  Weight     = round(wt_weights, 3)
)

view(wt_waic_tab)
```




## Offspring Sex Ratio




```{r}
#Set up competing models
#sex_mod will serve as breakpoint model

sex_lin <- brm(
  is_male ~ age +
    terminal:ageclass3 +
    (1 | animalID) + (1 | year_fct),
  data   = sex_dat,
  family = bernoulli(link = "logit"),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Quadratic Model: 
#Create a centered age and squared age 
sex_dat <- sex_dat %>% 
  mutate(
    age_c  = age - mean(age, na.rm = TRUE),
    age_c2 = age_c^2
  )

sex_quad <- brm(
  is_male ~ age_c + age_c2 +
    terminal:ageclass3 +
    (1 | animalID) + (1 | year_fct),
  data   = sex_dat,
  family = bernoulli(link = "logit"),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Now add WAIC comparisons to each of these 
# add WAIC to each fitted model
sex_mod <- add_criterion(sex_mod, "waic")
sex_quad  <- add_criterion(sex_quad,  "waic")
sex_lin   <- add_criterion(sex_lin,   "waic")

#Quick Comparison
loo_compare(sex_mod, sex_quad, sex_lin, criterion = "waic")

#Then list out/ summary
sex_mods <- list(
  Breakpoint = sex_mod,
  Quadratic  = sex_quad,
  Linear     = sex_lin
)

#Now we prepare it to be in a table with weights for docs!
# extract WAIC estimates
waic_sex <- c(
  Breakpoint = sex_mod$criteria$waic$estimates["waic", "Estimate"],
  Quadratic  = sex_quad$criteria$waic$estimates["waic", "Estimate"],
  Linear     = sex_lin$criteria$waic$estimates["waic", "Estimate"]
)

# ΔWAIC relative to best model
sex_min_waic   <- min(waic_sex)
sex_delta_waic <- waic_sex - sex_min_waic

# model weights based on WAIC
sex_weights <- exp(-0.5 * sex_delta_waic)
sex_weights <- sex_weights / sum(sex_weights)

# Build comparison table
sex_waic_tab <- tibble::tibble(
  Model      = names(waic_sex),
  WAIC       = round(waic_sex, 2),
  `Δ WAIC`   = round(sex_delta_waic, 2),
  Weight     = round(sex_weights, 3)
)

view(sex_waic_tab)
```




## Probability of pup survival




```{r}
#Set up competing models
#pup_surv_mod will serve as breakpoint model

pup_lin <- brm(
  pup_surv_int ~ age +
    terminal:ageclass3 +
    (1 | animalID) + (1 | year_fct),
  data   = surv_recr_data,
  family = bernoulli(link = "logit"),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Quadratic Model: 
#Create a centered age and squared age 
surv_recr_data <- surv_recr_data %>% 
  mutate(
    age_c  = age - mean(age, na.rm = TRUE),
    age_c2 = age_c^2
  )

pup_quad <- brm(
  pup_surv_int ~ age_c + age_c2 +
    terminal:ageclass3 +
    (1 | animalID) + (1 | year_fct),
  data   = surv_recr_data,
  family = bernoulli(link = "logit"),
  iter   = 4000,
  chains = 4,
  backend = "rstan"
)

#Now add WAIC comparisons to each of these 
# add WAIC to each fitted model
# add WAIC to each fitted model
pup_surv_mod <- add_criterion(pup_surv_mod, "waic")
pup_quad  <- add_criterion(pup_quad,  "waic")
pup_lin   <- add_criterion(pup_lin,   "waic")

#Quick Comparison
loo_compare(pup_surv_mod, pup_quad, pup_lin, criterion = "waic")

#Then list out/ summary
pup_mods <- list(
  Breakpoint = pup_surv_mod,
  Quadratic  = pup_quad,
  Linear     = pup_lin
)

#Now we prepare it to be in a table with weights for docs!
# extract WAIC estimates
waic_pup <- c(
  Breakpoint = pup_surv_mod$criteria$waic$estimates["waic", "Estimate"],
  Quadratic  = pup_quad$criteria$waic$estimates["waic", "Estimate"],
  Linear     = pup_lin$criteria$waic$estimates["waic", "Estimate"]
)

# ΔWAIC relative to best model
pup_min_waic   <- min(waic_pup)
pup_delta_waic <- waic_pup - pup_min_waic

# model weights based on WAIC
pup_weights <- exp(-0.5 * pup_delta_waic)
pup_weights <- pup_weights / sum(pup_weights)

# Build comparison table
pup_waic_tab <- tibble::tibble(
  Model      = names(waic_pup),
  WAIC       = round(waic_pup, 2),
  `Δ WAIC`   = round(pup_delta_waic, 2),
  Weight     = round(pup_weights, 3)
)

view(pup_waic_tab)
```

